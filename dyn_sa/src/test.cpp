#include <iostream>
#include <cstdlib>

#include <fstream>

#include "dynSA.h"
#include "utils.h"
#include <string.h>
#include "types.h"
#include <sstream>
using namespace std;
using namespace dynsa;

extern "C" {
#include "time.h"
#include "sys/time.h"
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
}

#include <vector>
#include <tuple>
#include <time.h>
#include <sys/resource.h>
#include <sys/time.h>

#include "../../src/include/ezOptionParser.hpp"

string resultsPath="";

using namespace ez;

void format_path(std::string &path){
        if(path[path.length()-1]!='/')
                    path+="/";
}

uchar *get_reference_sequence(char *filename, size_t &n, int termin) {
  std::ifstream file(filename);
  if (!file)
    {
      std::cout << "Error reading file: " << filename << std::endl;
      exit(EXIT_FAILURE);
    }

  file.seekg(0, ios::end);
  n = file.tellg();
  if (termin)
    n++;
  file.seekg(0, ios::beg);

  uchar *text = new uchar[n+1];

  char c;
  size_t i=0;

  while (file.get(c))
    {
      text[i]=c;//(c=='\n'||c=='\r')?'X':c;
      i++;
    }
  file.close();

  if (termin)
    text[n-1]=0;
  text[n]=0;
  return text;
}

void usage(char *program) {
    cout << "ezOptionParser should tell you \n";
    //cout << "Usage (EARLIER): " << program << " <filename> [lcp] [getSA <num_queries>] [insert (<file to ins.> <pos of ins.>)+] [delete (<pos. to delete> <length of deletion>)+] " << endl;
    exit(1);
}

//Print time elapsed in seconds
void print_time_elapsed(std::string desc, struct timeval* start, struct timeval* end) {
    
    struct timeval elapsed;
    
    if(start->tv_usec > end->tv_usec) {
        end->tv_usec += 1000000;
        end->tv_sec--;
    }
    elapsed.tv_usec = end->tv_usec - start->tv_usec;
    elapsed.tv_sec  = end->tv_sec  - start->tv_sec;
    float time_elapsed = (elapsed.tv_sec*1000000 + elapsed.tv_usec)/1000000.f;
    std::cout << desc << " Total Time Elapsed = " << time_elapsed << " seconds" <<std::endl;

    return;
}

bool fileExists(std::string filePath) {

	if (!std::ifstream(filePath)) {
		std::cout << "File not found: " << filePath << std::endl;
		return false;
	}
	return true;
}

/**
 * Parses the input file which contains the edits to perform on a genome
 * and transforms the required fields into a tuple<strng, string, string>
 *
 * Example input lines:
 * 	I 4439799 T
 * 	S 2261415 C
 * 	D 494753 494753
 *
 * The parsed output generated by this helper function is used by benchmark_edits()
 */
void parse_edit_file(std::vector<std::tuple<std::string, std::string, std::string>> &edits, std::string edits_file_path) {

	std::string g;
	std::ifstream edits_file(edits_file_path);

	std::string edit;
	if (edits_file.is_open()) {
		while (!edits_file.eof())
    	{
    		std::getline(edits_file,edit);
    		if(edit.length()>0){
				std::stringstream edit_stream(edit);
				std::string e;
				std::vector<std::string> edit_details;
				while (std::getline(edit_stream, e, ' ')) {
					edit_details.push_back(e);
				}
				edits.push_back(make_tuple(edit_details[0], edit_details[1], edit_details[2]));
    		}
    	}
    } else {
		std::cout << "Failed to open file: " << edits_file_path << std::endl;
		std::cout << "Quitting." << std::endl;
		exit(-1);
	}

	return;
}


void benchmark_edits(std::string genome_file, std::string edits_file,
		long num_edits, std::string outputUpdatedGenomeFile) {

	size_t n;
	uchar *text;
	DynSA *wt;
	float *f;
	size_t total_length_ins = 0, total_length_del = 0;
	struct timeval start, end;
	struct timezone tzp;

	char *ge = new char[genome_file.length() + 1];
	strcpy((char*) ge, genome_file.c_str());
	text = get_reference_sequence(ge, n, 1);

	// Creates the structure for dynamic suffix array
	wt = new DynSA(false);
	f = DynRankS::createCharDistribution(text,
			(n > 10000000) ? n + 1 : 10000000, 1);
	wt->initEmptyDynSA(f);
	gettimeofday(&start, &tzp);
	wt->addText(text, n);
	gettimeofday(&end, &tzp);
	print_time_elapsed("DynSA: Building Index: ", &start, &end);

	int test_count = 0;

	std::vector<std::tuple<std::string, std::string, std::string>> edit;
	parse_edit_file(edit, edits_file);

	if(num_edits<=0){
		num_edits=edit.size();
	}

	cout<<"Number of edits: "<<num_edits<<endl;
	gettimeofday(&start, &tzp);

	for (auto it : edit) {

		if (test_count >= num_edits)
		{
			gettimeofday(&end, &tzp);
			std::string message = std::string("DynSA: 5% Updates: ");
			print_time_elapsed(message, &start, &end);
			break;
		}

		if (test_count == num_edits/5)
		{
			gettimeofday(&end, &tzp);
			std::string message = std::string("DynSA: 1% Updates: ");
			print_time_elapsed(message, &start, &end);
		}

		if (test_count == num_edits/10)
		{
			gettimeofday(&end, &tzp);
			std::string message = std::string("DynSA: 0.5% Updates: ");
			print_time_elapsed(message, &start, &end);
		}

		if (test_count == num_edits/50)
		{
			gettimeofday(&end, &tzp);
			std::string message = std::string("DynSA: 0.1% Updates: ");
			print_time_elapsed(message, &start, &end);
		}

		if (test_count == num_edits/500)
		{
			gettimeofday(&end, &tzp);
			std::string message = std::string("DynSA: 0.01% Updates: ");
			print_time_elapsed(message, &start, &end);
		}

		if (get<0>(it) == "I") {
			//cout<<"Inserting "<<get<2>(it)<<" at "<<get<1>(it) << endl;
			uchar *ins = new uchar[(get<2>(it)).length() + 1];
			strcpy((char*) ins, (get<2>(it)).c_str());
			wt->addChars(ins, get<2>(it).length(),
					stol(get<1>(it), nullptr, 10) + 2); //wt->addChars(patterns[i], length_patterns[i], ins_indexes[i]+1);
			total_length_ins += get<2>(it).length();
			test_count++;
		}
		if (get<0>(it) == "D") {
			//cout<<"Deleting from "<< get<1>(it)+1 <<" to "<< stol(get<2>(it))+1 << endl;
			wt->deleteChars(
					stol(get<2>(it), nullptr, 10)
							- stol(get<1>(it), nullptr, 10) + 1,
					stol(get<1>(it), nullptr, 10) + 1); //wt->deleteChars(length_del[i], del_indexes[i]+1);
			total_length_del += (stol(get<2>(it), nullptr, 10)
					- stol(get<1>(it), nullptr, 10));
			test_count++;
		}
		if (get<0>(it) == "S") {
			//cout<<"SNP "<<get<2>(it)<<" at "<<get<1>(it) << endl;
			uchar *ins = new uchar[(get<2>(it)).length() + 1];
			strcpy((char*) ins, (get<2>(it)).c_str());

			//cout<<"Deleting from "<< get<1>(it) <<" to "<< (get<2>(it)).length()+get<1>(it)-1 << endl;
			wt->deleteChars((get<2>(it)).length(),
					stol(get<1>(it), nullptr, 10) + 1);
			//cout<<"Inserting "<<get<2>(it)<<" at "<<get<1>(it) << endl;
			wt->addChars(ins, get<2>(it).length(),
					stol(get<1>(it), nullptr, 10) + 1);
			test_count++;
		}
	}


	if (outputUpdatedGenomeFile != "") {

		//Regenerating the updated reference sequence from the BWT F&L
		n = wt->getSize();
		size_t i = 1, length = 0;
		char c = (*wt)[i];
		uchar *newtext = new uchar[n];
		newtext[n - 1] = '\0';
		//Retrieve the text
		while (c != 0) {
			c = (*wt)[i];
			newtext[n - length - 2] = c;
			i = wt->LFmapping(i);
			length++;
			if (length > n)
				break;
		}

		//Write updated genome to file 
		std::cout<<"Writing the updated genome to file"<<std::endl;
		std::string output_file(outputUpdatedGenomeFile);
		std::ofstream outfile(output_file);
		outfile << newtext;
		outfile.close();
	}

	//std::cout << text << endl;
	//std::cout << newtext << endl;

	/*
	 if (n!=length) { // Clearly, if length is different from the expected length, we have a big problem!
	 cout << "Houston, we have a problem...   " << " n = " << n << ", length = " << length << endl;
	 exit(2);
	 } else {
	 //Verify here if the generated string is correct
	 }
	 */

	delete[] text;
	delete[] f;
	cout << "Done..." << endl;

}

/**
 * Parses the input file which contains the edits to perform on a genome,
 * followed by search queries, and transforms the required fields into a
 * tuple<strng, string, string>
 *
 * A typical input file would consist of sets of edits and search queries -
 * a few lines of edits, followed by a few search strings, and so on.
 * Example input lines:
 * I 442077 ATC
 * D 3975001 3975005
 * I 2052837 GCG
 * Q GCGCCAGCGTCGGCAAGGGT N 1
 * Q TGTTAACGCGCTGGCGGCGA N 1
 * Q TTCCACGCCTTACACCGTAC N 1
 *
 * The parsed output generated by this helper function is used by benchmark_search()
 *
 */
void parse_query_file(const std::string edits_queries_file_path,
		std::vector<std::tuple<std::string, std::string, std::string>> &edits,
		std::vector<std::tuple<std::string, std::string, std::string, long>> &queries,
		long queryFrequency, long queryCount, long iterations) {

	std::ifstream edits_queries_file(edits_queries_file_path);

	if (edits_queries_file.is_open()) {

		for (int j = 0; j < iterations; j++) {

			std::string g;

			for (int i = 0; i < queryFrequency; i++) {

				std::getline(edits_queries_file, g);
				std::stringstream edit_stream(g);
				if (g.length() > 0) {
					std::string e;
					std::vector<std::string> edit_details;
					while (std::getline(edit_stream, e, ' ')) {
						edit_details.push_back(e);
					}
					edits.push_back(
							make_tuple(edit_details[0], edit_details[1], edit_details[2]));
				}
			}

			for (int i = 0; i < queryCount; i++) {

				std::getline(edits_queries_file, g);
				std::stringstream query_stream(g);
				if (g.length() > 0) {
					std::string q;
					std::vector<std::string> query_details;
					while (std::getline(query_stream, q, ' ')) {
						query_details.push_back(q);
					}
					queries.push_back(
							make_tuple(query_details[0], query_details[1],
									query_details[2], stol(query_details[3], nullptr, 10)));
				}
			}
		}
	}  else {
		std::cout <<  "Failed to open file: " << edits_queries_file_path << std::endl << "Exiting program" << std::endl ;
		exit(-1);
	}
}


void benchmark_search(std::string genome_file,
		const std::string path_to_query_file, long queryfreq, long querycount,
		long iterations) {

	size_t n;
	uchar *text;
	DynSA *wt;
	float *f;
	size_t total_length_ins = 0, total_length_del = 0;
	struct timeval start, end;
	struct timezone tzp;

	char *ge = new char[genome_file.length() + 1];
	strcpy((char*) ge, genome_file.c_str());
	text = get_reference_sequence(ge, n, 1);

	// Creates the structure for dynamic suffix array
	wt = new DynSA(false);
	f = DynRankS::createCharDistribution(text,
			(n > 10000000) ? n + 1 : 10000000, 1);
	wt->initEmptyDynSA(f);
	gettimeofday(&start, &tzp);
	wt->addText(text, n);
	gettimeofday(&end, &tzp);
	print_time_elapsed("DynSA: Building Index: ", &start, &end);

	//Read data
	std::vector<std::tuple<std::string, std::string, std::string>> edit;
	std::vector<std::tuple<std::string, std::string, std::string, long>> query;

	parse_query_file(path_to_query_file, edit, query, queryfreq, querycount,
			iterations);

	//std::string resultsFile = resultsPath + ".query.out";
	//std::ofstream query_out_file(resultsFile);
	//cout << "Queries output file: "<< resultsFile;


	auto it = edit.begin();
	auto q = query.begin();

	for (int i = 0; i < iterations; i++) {

		for (int j = 0; j < queryfreq; j++) {

			if (get<0>(*it) == "I") {
				//cout<<"Inserting "<<get<2>(it)<<" at "<<get<1>(it) << endl;
				uchar *ins = new uchar[(get<2>(*it)).length() + 1];
				strcpy((char*) ins, (get<2>(*it)).c_str());
				wt->addChars(ins, get<2>(*it).length(),
						stol(get<1>(*it), nullptr, 10) + 2); //wt->addChars(patterns[i], length_patterns[i], ins_indexes[i]+1);
				total_length_ins += get<2>(*it).length();
			}
			else if (get<0>(*it) == "D") {
				//cout<<"Deleting from "<< get<1>(*it)+1 <<" to "<< stol(get<2>(*it))+1 << endl;
				wt->deleteChars(
						stol(get<2>(*it), nullptr, 10)
								- stol(get<1>(*it), nullptr, 10) + 1,
						stol(get<1>(*it), nullptr, 10) + 1); //wt->deleteChars(length_del[i], del_indexes[i]+1);
				total_length_del += (stol(get<2>(*it), nullptr, 10)
						- stol(get<1>(*it), nullptr, 10));
			}
		}

		gettimeofday(&start, &tzp);
		for (int j = 0; j < querycount; j++) {
			uchar *query = new uchar[(get<1>(*q)).length() + 1];
			strcpy((char*) query, (get<1>(*q)).c_str());
			//query_out_file << get<1>(*q) << "\t";
				size_t* pos = wt->locate(query);
				//for (unsigned int i = 0; i < sizeof(pos) / sizeof(size_t); i++) {
				//	query_out_file << pos[i] << " ";
				//}
			//query_out_file << std::endl;
			q++;
		}
		gettimeofday(&end, &tzp);
		std::string message = std::string("DynSA: Search: ");
		print_time_elapsed(message, &start, &end);

	}

	delete[] text;
	delete[] f;
	cout << "Done..." << endl;

}

void benchmark_substr(std::string genome_file, std::string edits_file,
		long num_edits, std::string substr_file_path) {

	size_t n;
	uchar *text;
	DynSA *wt;
	float *f;
	struct timeval start, end;
	struct timezone tzp;
	size_t total_length_ins = 0, total_length_del = 0;
	char *ge = new char[genome_file.length() + 1];
	strcpy((char*) ge, genome_file.c_str());

	text = get_reference_sequence(ge, n, 1);

	// Creates the structure for dynamic suffix array
	wt = new DynSA(false);
	f = DynRankS::createCharDistribution(text,
			(n > 10000000) ? n + 1 : 10000000, 1);
	wt->initEmptyDynSA(f);
	gettimeofday(&start, &tzp);
	wt->addText(text, n);
	gettimeofday(&end, &tzp);
	print_time_elapsed("DynSA: Building Index: ", &start, &end);

	{

		int test_count = 1;

		std::vector<std::tuple<std::string, std::string, std::string>> edit;
		parse_edit_file(edit, edits_file);
		if(num_edits==0){
			num_edits=edit.size();
		}

		cout<<"Number of edits: "<<num_edits<<endl;
		gettimeofday(&start, &tzp);

		for (auto it : edit) {

			if (test_count >= num_edits)
			{
				gettimeofday(&end, &tzp);
				std::string message = std::string("DynSA: 100% of Total Updates: ");
				print_time_elapsed(message, &start, &end);
				break;
			}

			if (test_count == num_edits/5)
			{
				gettimeofday(&end, &tzp);
				std::string message = std::string("DynSA: 20% of Total Updates: ");
				print_time_elapsed(message, &start, &end);
			}

			if (test_count == num_edits/10)
			{
				gettimeofday(&end, &tzp);
				std::string message = std::string("DynSA: 10% of Total Updates: ");
				print_time_elapsed(message, &start, &end);
			}

			if (test_count == num_edits/50)
			{
				gettimeofday(&end, &tzp);
				std::string message = std::string("DynSA: 2% of Total Updates: ");
				print_time_elapsed(message, &start, &end);
			}

			if (test_count == num_edits/500)
			{
				gettimeofday(&end, &tzp);
				std::string message = std::string("DynSA: 0.2% Updates: ");
				print_time_elapsed(message, &start, &end);
			}

			if (get<0>(it) == "I") {
				//cout<<"Inserting "<<get<2>(it)<<" at "<<get<1>(it) << endl;
				uchar *ins = new uchar[(get<2>(it)).length() + 1];
				strcpy((char*) ins, (get<2>(it)).c_str());
				wt->addChars(ins, get<2>(it).length(),
						stol(get<1>(it), nullptr, 10) + 2); //wt->addChars(patterns[i], length_patterns[i], ins_indexes[i]+1);
				total_length_ins += get<2>(it).length();
				test_count++;
			}
			if (get<0>(it) == "D") {
				//cout<<"Deleting from "<< get<1>(it)+1 <<" to "<< stol(get<2>(it))+1 << endl;
				wt->deleteChars(
						stol(get<2>(it), nullptr, 10)
								- stol(get<1>(it), nullptr, 10) + 1,
						stol(get<1>(it), nullptr, 10) + 1); //wt->deleteChars(length_del[i], del_indexes[i]+1);
				total_length_del += (stol(get<2>(it), nullptr, 10)
						- stol(get<1>(it), nullptr, 10));
				test_count++;
			}
			if (get<0>(it) == "S") {
				//cout<<"SNP "<<get<2>(it)<<" at "<<get<1>(it) << endl;
				uchar *ins = new uchar[(get<2>(it)).length() + 1];
				strcpy((char*) ins, (get<2>(it)).c_str());

				//cout<<"Deleting from "<< get<1>(it) <<" to "<< (get<2>(it)).length()+get<1>(it)-1 << endl;
				wt->deleteChars((get<2>(it)).length(),
						stol(get<1>(it), nullptr, 10) + 1);
				//cout<<"Inserting "<<get<2>(it)<<" at "<<get<1>(it) << endl;
				wt->addChars(ins, get<2>(it).length(),
						stol(get<1>(it), nullptr, 10) + 1);
				test_count++;
			}
		}

	}
	//Extract substrings
	std::vector<std::pair<long, long>> substrings;
	std::ifstream substr_file(substr_file_path);
	std::string line, pos, len;

	if (substr_file.is_open()) {
		while (!substr_file.eof()) {
			std::getline(substr_file, line);
			if (line.length() > 0) {
				std::stringstream stream(line);
				std::string l;
				std::vector<std::string> substr_details;
				while (std::getline(stream, l, ',')) {
					substr_details.push_back(l);
				}
				substrings.push_back(
						std::make_pair(stol(substr_details[0], nullptr, 10),
								stol(substr_details[1], nullptr, 10)));
			}
		}
	} else {
		std::cout << "Failed to open file: " << substr_file_path << std::endl;
		std::cout << "Exiting program" << std::endl;
		exit(-1);
	}

	gettimeofday(&start, &tzp);
	for (auto substr : substrings) {
		//std::cout << substr.first << " " << substr.second << std::endl;
		wt->retrieveTextFactor(substr.first, substr.second);
	}
	gettimeofday(&end, &tzp);
	std::string message = "Extracted " + std::to_string(substrings.size())
			+ " substrings: ";
	print_time_elapsed(message, &start, &end);

	delete[] text;
	delete[] f;
	cout << "Done..." << endl;

}

//Edited for benchmarking with SkipPatch
int main(int argc, const char *argv[]) {

	ezOptionParser opt;
	opt.overview = "Test dynamically-updateable index.";
	opt.syntax = "main [OPTIONS]";

	opt.add("", 0, 0, 0, "Help!", "-h", "-help", "--help", "--usage");

	opt.add("", 0, 1, 0, "The genome file.", "-g", "--genome");

	opt.add("", 0, 1, 0, "The edit file.", "-e", "--editsFile");
	opt.add("", 0, 1, 0, "The number of edits to perform.", "-n", "--numEdits");

	opt.add("", 0, 1, 0, "The edit file which contains both edits and queries (for benchmarking search).", "-q", "--editsQueriesFile");
	opt.add("", 0, 1, 0, "The query frequency (to be used only when benchmarking search).", "-qf", "--queryFrequency");
	opt.add("", 0, 1, 0, "The query count (to be used only when benchmarking search).", "-qc", "--queryCount");
	opt.add("", 0, 1, 0, "The number of iterations of edits and searches to perform (to be used only when benchmarking search).", "-it", "--iterations");

	opt.add("", 0, 1, 0, "The substrings file.", "-s", "--substrFile");
    opt.add("", 0, 1, 0, "Directory for writing logs", "-l", "--logPath");
    opt.add("", 0, 1, 0, "File path for writing the updated genome", "-o", "--output");

	opt.parse(argc, argv);

	if (opt.isSet("-h")) {
		std::string usage;
		opt.getUsage(usage, 80, ezOptionParser::ALIGN);
		std::cout << usage;
		return 1;
	}

	std::string genomeFile;
	if (opt.isSet("--genome")) {
		opt.get("--genome")->getString(genomeFile);
	} else {
		std::cout << "You can't build an index without a genome!" << std::endl;
		return 1;
	}

	std::string editsFile;
	if (opt.isSet("--editsFile")) {
		opt.get("--editsFile")->getString(editsFile);
	}

	long numEdits=0;
	if (opt.isSet("--numEdits")) {
		opt.get("--numEdits")->getLong(numEdits);
	}

	std::string substrFile;
	if (opt.isSet("--substrFile")) {
		opt.get("--substrFile")->getString(substrFile);
	}

	std::string editsQueriesFile = "";
	if (opt.isSet("--editsQueriesFile")) {
		opt.get("--editsQueriesFile")->getString(editsQueriesFile);
	}

	long queryFrequency;
	if (opt.isSet("--queryFrequency")) {
		opt.get("--queryFrequency")->getLong(queryFrequency);
	}

	long queryCount;
	if (opt.isSet("--queryCount")) {
		opt.get("--queryCount")->getLong(queryCount);
	}

	long iterations;
	if (opt.isSet("--iterations")) {
		opt.get("--iterations")->getLong(iterations);
	}

	std::string outputUpdatedGenomeFile="";
      if (opt.isSet("--output")) {
          opt.get("--output")->getString(outputUpdatedGenomeFile);
          format_path(outputUpdatedGenomeFile);
          outputUpdatedGenomeFile+="SAGenome.fa";
    }

	resultsPath = "../SA/";
	if (opt.isSet("--logPath")) {
		opt.get("--logPath")->getString(resultsPath);
		format_path(resultsPath);
		resultsPath +="SA.log";
	}

    // EDITS AND SUBSTRING TESTS CANNOT BE RUN AT THE SAME TIME!
	if (opt.isSet("--editsFile") && (!(opt.isSet("--substrFile")))) {
		if (fileExists(editsFile)) {
			std::cout <<  "Benchmarking edits" << std::endl;
			benchmark_edits(genomeFile, editsFile, numEdits, outputUpdatedGenomeFile);
		}
	}

    // EDITS AND SUBSTRING TESTS CANNOT BE RUN AT THE SAME TIME!
	if (opt.isSet("--substrFile") && fileExists(substrFile)) {
		std::cout <<  "Benchmarking substring extraction" << std::endl;
		if (fileExists(substrFile) && fileExists(editsFile)) {
			benchmark_substr(genomeFile,editsFile,numEdits,substrFile);
		}
		else{
			cout<<"Can't run substring benchmarks because either substring file or edits file is missing!";
		}
	}

	if (opt.isSet("--editsQueriesFile") && fileExists(editsQueriesFile) && opt.isSet("--queryFrequency") && opt.isSet("--queryCount") && opt.isSet("--iterations")) {
		if (queryFrequency > 0 && queryCount > 0 && iterations > 0) {
			std::cout << "Benchmarking search" << std::endl;
			if (fileExists(editsQueriesFile)) {
				benchmark_search(genomeFile, editsQueriesFile, queryFrequency, queryCount, iterations);
			}
		} else {
			std::cout << "There was a problem with one or more of the parameters provided for benchmarking search"<<std::endl;
		}
	}

}

